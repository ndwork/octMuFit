
function mu = muFitCVX( I, mask, z, z0, zR, eta )

  m = numel(I);

  % we use symmetric boundary conditions for D
  % this is part of the definition of TV regularization
  %dz = z(2:end) - z(1:end-1);
  %dz = [ dz; dz(end) ];
  dz = z(2) - z(1);
%   D = -eye( m );
%   for i=1:m-1
%     D(i,i+1) = 1;
%     D(i,:) = D(i,:) ./ dz;
%   end
%   D(m,:) = 0;
  D = makeD_1D(m, mask, dz);

  tmp = (z-z0)/zR;
  gPrimeOverG = -tmp ./ ( tmp.^2 + 1 );

  g = 1 ./ sqrt( tmp.^2 + 1 );

  ut = triu( ones(m-1,m-1) );
  utMask = repmat(mask(1:m-1)', [m-1, 1]);
  ut = ut.*utMask;
  ut = ut.*utMask';
  
  lt = tril( ones(m-1,m-1) );
  cvx_begin quiet
    %cvx_precision high

    variable gam(m)

%     minimize ( ...
%       norm( ...
%            ... % Integrate from z to D
%            1/2 * I(1:m-1) .* gam(1:m-1) ./ dz(1:m-1) ...
%            - 1/2 * I(m) * gam(m) / dz(m) ...
%            + 1/2 * ut * ( ...
%                I(1:m-1) ./ dz(1:m-1) .* gam(1:m-1) .* log( g(2:m)./g(1:m-1) ) ...
%              ) ...
%            - ut * I(1:m-1) ...
%           ...
%          ... % Integrate from 0 to z
%           + 1/2 * I(1) .* gam(1) / dz(1) ...
%           - 1/2 * I(1:m-1) .* gam(1:m-1) ./ dz(1:m-1) ...
%           + 1/2 * lt * ( ...
%               I(1:m-1) ./ dz(1:m-1) .* gam(1:m-1) .* log( g(2:m)./g(1:m-1) ) ...
%             ) ...
%           - lt * I(1:m-1) ...
%       ) ...
%       + eta * norm( D * gam, 1 ) ...
%     )


%     minimize ( ...
%       norm( ...
%            ... % Integrate from z to D
%            1/2 * I(1:m-1) .* gam(1:m-1) ./ dz(1:m-1) ...
%            - 1/2 * I(m) * gam(m) / dz(m) ...
%            + 1/2 * ut * ( ...
%                I(1:m-1) ./ dz(1:m-1) .* gam(1:m-1) .* log( g(2:m)./g(1:m-1) ) ...
%              ) ...
%            - ut * I(1:m-1) ...
%       ) ...
%       + eta * norm( D * gam, 1 ) ...
%     )


    minimize ( ...
      0.5 * sum( ...
           ... % Integrate from z to D
           ( 1/2 * I(1:m-1).*mask(1:m-1).* gam(1:m-1) ./ dz ...
           - 1/2 * I(m) * gam(m).*mask(1:m-1)./ dz ...
           + 1/2 * ut * ( ...
               I(1:m-1) ./ dz .* gam(1:m-1) .* log( g(2:m)./g(1:m-1) ) ...
             ) ...
           - ut * I(1:m-1) ...
           ).^2 ...
      ) ...
      + eta * norm( D * gam, 1 ) ...
    )




%     minimize ( ...
%       sum( ...
%           ... % Integrate from 0 to z
%           (  1/2 * I(1) .* gam(1) / dz(1) ...
%           - 1/2 * I(1:m-1) .* gam(1:m-1) ./ dz(1:m-1) ...
%           + 1/2 * lt * ( ...
%               I(1:m-1) ./ dz(1:m-1) .* gam(1:m-1) .* log( g(2:m)./g(1:m-1) ) ...
%             ) ...
%           - lt * I(1:m-1) ...
%       ).^2 ) ...
%       + eta * norm( D * gam, 1 ) ...
%     )


    subject to
      gam >= 0
      diag(1-mask)*gam == 0

  cvx_end

  mu = 1 ./ gam;

end
